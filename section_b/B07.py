t = int(input())
n = int(input())
a = [0] * (t+1)
for i in range(n):
    l, r = map(int,input().split())
    a[l] += 1
    a[r] -= 1
    
for i in range(1,t):
    a[i] += a[i-1]

print(*a[:t],sep='\n') # t未満を表示,つまり0からt-1のt個

# 以下のように答えを出力することも可能である
# ans変数を用意して順次、累積和を求めて表示する方法である
# この方法ではリストに格納しないため、累積和を使って計算をする問題には不適切である
# ans=0
# for i in range(T):
#   ans=ans+a[i]
#   print(ans)


# t+0.5 について
# この問題の難しい所は出力が t+0.5 (0 <= t <= T-1) での人数となっている点である
# 0.5という半端な値が加算されているためリストのインデックスとの対応付けを考えるのが難しくなっている
# わかりやすくしたいので t の値とインデックスは以下のように一致させる
# またリストに格納するのは t+0.5 での人数を格納するようにする

# t=0 のときは a[0] を参照し t=0.5 での人数を見れるようにする
# t=1 のときは a[1] を参照し t=1.5 での人数を見れるようにする
# t=T-1 のときは a[T-1] を参照し t=(T-1)+0.5 での人数を見れるようにする

# このように設計すると出力結果はa[0]～a[T-1]を表示させればいいことになる

# 初期化するリストの要素数について考える
# まず最低限は表示する範囲を用意しなければならないのでa[T-1]の要素数は必要である
# a[T]は時刻T+0.5での滞在人数を格納する位置であるため必要のない値である
# しかし累積和において +1 をする位置と -1 をする位置の関係上
# リストを長めに設定しなければならない場合がある
# 今回の場合、-1をする位置がa[r+1]の位置ではなくa[r]であるため余分な要素はいらない
# 他にも余分な要素が必要な場合がある
# 退勤時間がTのときはa[T]を-1する必要がある
# このa[T]はT+0.5での人数で本来必要のない要素であるが退勤時間のために必要となっている
# つまり初期化するリストの要素数は0からTまでのT+1個である

# 次に累積和において +1 をする位置と -1 をする位置について考える
# 結論から言うと、a[l]++とa[r]--となる
# 具体例で考えると0時から5時までの場合、0で +1 をして5で -1 をすればよい
# indexが5の場合について考えると、a[5]は t=5.5 での人数となってほしい
# 5時に退勤する場合、a[5]で -1 しないと t=5.5 での人数にズレが発生してしまう

# 次に累積和の繰り返し範囲について考える
# 表示する範囲はa[0]～a[T-1]までなのでa[0]～a[T-1]の範囲で累積和を計算すればいいことになる
# a[i] += a[i-1]と計算すればよいがa[0]は計算しなくてよい
# そのため繰り返し範囲はa[1]～a[T-1]である